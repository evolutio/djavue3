---
description: Arquitetura em Camadas do Django - urls â†’ views â†’ services â†’ models
globs:
  - "**/*/views.py"
  - "**/*/urls.py"
  - "**/*/service/**/*.py"
alwaysApply: false
---

# ðŸ¦„ Arquitetura Django - DjaVue

## Camadas da AplicaÃ§Ã£o

O DjaVue segue uma arquitetura em camadas clara e testÃ¡vel:

```
Cliente HTTP â†’ urls â†’ views â†’ services â†’ models â†’ ORM
                      â†“
                   Schemas (validaÃ§Ã£o)
```

### 1. URLs (`urls.py`)
- **Responsabilidade**: Definir rotas da API
- **Regras**:
  - Usar `path()` do Django ou routers do django-ninja
  - Prefixo `/api/[app_name]/` para todas as rotas
  - Agrupar rotas por contexto (app)

### 2. Views (`views.py`)
- **Responsabilidade**: Receber requisiÃ§Ãµes, validar entrada, chamar services, retornar respostas
- **Regras**:
  - Views devem ser **enxutas** (thin controllers)
  - NÃ£o devem conter regras de negÃ³cio
  - Validar dados de entrada (schemas ou validaÃ§Ã£o manual)
  - Usar decorators de autenticaÃ§Ã£o: `@ajax_login_required`, `@ajax_staff_required`, `@ajax_superuser_required`
  - Sempre usar `@csrf_exempt` para APIs
  - Retornar `JsonResponse` com status HTTP apropriado
  - Usar logging: `logger.info()`, `logger.error()`

**Exemplo**:
```python
@csrf_exempt
@ajax_login_required
def add_task(request):
    """Adiciona nova tarefa"""
    logger.info("API add new task.")
    body = json.loads(request.body)
    description = body.get("description")
    
    # ValidaÃ§Ã£o bÃ¡sica
    if not description:
        raise ValueError("description: Field required")
    
    # Chamar service
    new_task = task_svc.add_task(description)
    return JsonResponse(new_task, status=201)
```

### 3. Services (`service/`)
- **Responsabilidade**: Implementar **regras de negÃ³cio**
- **Regras**:
  - Services sÃ£o **Python puro** (nÃ£o dependem do Django, exceto models)
  - Devem ser **facilmente testÃ¡veis**
  - Nomenclatura: `[nome]_svc.py` (ex: `task_svc.py`)
  - FunÃ§Ãµes retornam `dict` (resultado de `model.to_dict_json()`)
  - Usar exceÃ§Ãµes customizadas: `BusinessError`, `ServiceUnavailableError`
  - Sempre validar entrada antes de processar

**Exemplo**:
```python
from ..models import Task
from ...base.exceptions import BusinessError

def add_task(description: str) -> dict:
    logger.info("SERVICE add new task")
    if not isinstance(description, str):
        raise BusinessError("Invalid description")
    
    if not description or not description.strip():
        raise BusinessError("Invalid description")
    
    task = Task(description=description)
    task.save()
    logger.info("SERVICE task created.")
    return task.to_dict_json()
```

### 4. Models (`models.py`)
- **Responsabilidade**: Definir estrutura de dados e acesso ao banco
- **Regras**:
  - Herdar de `models.Model`
  - Implementar mÃ©todo `to_dict_json()` para serializaÃ§Ã£o
  - Usar `__str__()` para representaÃ§Ã£o legÃ­vel
  - Campos devem ter `max_length` apropriado

**Exemplo**:
```python
class Task(models.Model):
    description = models.CharField(max_length=512)
    done = models.BooleanField(default=False)
    
    def __str__(self):
        return self.description
    
    def to_dict_json(self):
        return {
            "id": self.id,
            "description": self.description,
            "done": self.done,
        }
```

### 5. Schemas (`schemas.py`) - Django Ninja
- **Responsabilidade**: ValidaÃ§Ã£o de entrada e saÃ­da
- **Regras**:
  - Usar `Schema` do django-ninja para entrada
  - Usar `ModelSchema` para saÃ­da baseada em models
  - Validadores com `@field_validator` do Pydantic
  - Nomenclatura: `[Nome]SchemaIn`, `[Nome]Schema`, `List[Nome]Schema`

**Exemplo**:
```python
from ninja import Schema, ModelSchema
from pydantic import field_validator

class TaskSchemaIn(Schema):
    description: str
    
    @field_validator("description")
    def valid_description(cls, description: str) -> str:
        if description and len(description) <= 2:
            raise ValueError("It must be at least 3 characters long.")
        return description

class TaskSchema(ModelSchema):
    class Meta:
        model = Task
        fields = ["id", "description", "done"]
```

## OrganizaÃ§Ã£o de Apps

- Cada **contexto de negÃ³cio** Ã© uma app Django separada
- Apps sÃ£o organizadas na raiz do projeto Django
- Estrutura padrÃ£o de uma app:
  ```
  [app_name]/
  â”œâ”€â”€ __init__.py
  â”œâ”€â”€ apps.py
  â”œâ”€â”€ admin.py
  â”œâ”€â”€ urls.py          # Rotas
  â”œâ”€â”€ views.py         # Views
  â”œâ”€â”€ schemas.py       # Schemas (django-ninja)
  â”œâ”€â”€ models.py        # Models
  â”œâ”€â”€ service/         # Services
  â”‚   â”œâ”€â”€ __init__.py
  â”‚   â””â”€â”€ [nome]_svc.py
  â”œâ”€â”€ migrations/      # Migrations
  â”œâ”€â”€ tests/           # Testes
  â””â”€â”€ templates/       # Templates (se necessÃ¡rio)
  ```

## AutenticaÃ§Ã£o

- Usar decorators customizados de `commons.django_views_utils`:
  - `@ajax_login_required`: Requer usuÃ¡rio autenticado
  - `@ajax_staff_required`: Requer usuÃ¡rio staff
  - `@ajax_superuser_required`: Requer superusuÃ¡rio
- Retornar 401 quando nÃ£o autenticado
- Usar `request.user` para acessar usuÃ¡rio logado

## Logging

- Sempre usar logging em views e services
- PadrÃ£o: `logger = logging.getLogger(__name__)`
- Usar nÃ­veis apropriados: `info`, `error`, `warning`
- Incluir contexto relevante nas mensagens

## ExceÃ§Ãµes

- Usar exceÃ§Ãµes customizadas de `base.exceptions`:
  - `BusinessError`: Erros de regra de negÃ³cio
  - `ServiceUnavailableError`: ServiÃ§os indisponÃ­veis
- NÃ£o expor detalhes tÃ©cnicos nas respostas de erro
